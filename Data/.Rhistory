View(WC)
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode) #The list of edges
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- 1
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed")
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 100 #default value
}else{
Nodes$Qual <- Parth[,Quality]
}
Nodes$Qual <- 100 #default value, can be changed
Nodes$PermDS <- 1 #default value, completely permeable
Nodes$PermUS <- Parth$PermPass #assigning a permeability to move from segment downstream into the focal segment
Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
Parth[,Quality]
#list("graph" = graph, "Nodes" = Nodes)
}
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
WC.prep
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode) #The list of edges
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- 1
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed")
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 100 #default value
}else{
Nodes$Qual <- Parth[,Quality]
}
Nodes$Qual <- 100 #default value, can be changed
Nodes$PermDS <- 1 #default value, completely permeable
Nodes$PermUS <- Parth$PermPass #assigning a permeability to move from segment downstream into the focal segment
Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
#Parth[,Quality]
list("graph" = graph, "Nodes" = Nodes)
}
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
WC.prep <- calc.prep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode) #The list of edges
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- 1
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed")
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 100 #default value
}else{
Nodes$Qual <- Parth[,Quality]
}
#Nodes$Qual <- 100 #default value, can be changed
Nodes$PermDS <- 1 #default value, completely permeable
Nodes$PermUS <- Parth$PermPass #assigning a permeability to move from segment downstream into the focal segment
Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
#Parth[,Quality]
list("graph" = graph, "Nodes" = Nodes)
}
WC.prep <- calc.prep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
WC <- read.csv(file = "testWC.csv", header=T) #Select file that describes network
View(WC)
WC.prep <- calc.prep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
DCI.calc <- function(nodefile, graphfile, mouth, calc.DCIs = 0){
#Construct a table with the start and end of each path between all segments, length of that path,
#the product of the permeabilites of barriers on that path, the length of the start segment, and the length of the last segment
all.paths <- NULL
for (b in 1:length(nodefile$ID)) {
k <- unique(nodefile$ID)[b]
paths <- all_simple_paths(graph=graphfile, from=k, mode = "all") #returns path from a segment to all other segements
start <- sapply(paths, "[[", 1) #Identify the starting segment
end <- sapply(paths, tail, 1) #Identify the final segment
p.length <- NULL
pass <- NULL
for (j in 1:(length(unique(nodefile$ID))-1)) {
p.length2 <- 0
pass2 <- 1
for (c in paths[[j]]) {
i <- unique(nodefile$ID)[c]
p.length2 <- p.length2 + (nodefile$Area[i] * nodefile$Qual[i]) #length of the path. Multiplied by quality
pass2 <- pass2 * (nodefile$PermUS[i] * nodefile$PermDS[i])
}
p.length <- c(p.length, p.length2)
pass <- c(pass, pass2)
}
all.paths2 <- data.frame(start, end, p.length, pass)
itself <- c(k, k, nodefile$Area[k], nodefile$PermUS[k] * nodefile$PermUS[k])
all.paths <- rbind(all.paths, all.paths2, itself)
}
all.paths$Start.Length <- nodefile$Area[match(all.paths$start, nodefile$ID)]
all.paths$End.Length <- nodefile$Area[match(all.paths$end, nodefile$ID)]
#DCIp Calculation
tot.length <- sum(nodefile$Area)
DCIp <- 0
for (i in 1:nrow(all.paths)) {
DCIp <- DCIp + (all.paths$pass[i] * (all.paths$Start.Length[i]/tot.length) * (all.paths$End.Length[i]/tot.length))
}
DCId.data <- all.paths[all.paths$end==mouth, ]
DCId.data$val1 <- DCId.data$pass * (DCId.data$Start.Length/tot.length)
DCId <- sum(DCId.data$val1)
#Combine DCIp and DCId into output
DCI.results <- data.frame(DCIp, DCId)
colnames(DCI.results) <- c("DCIp", "DCId")
#Calculating DCIs, recalculate DCId for each segement as the mouth of the network
if(calc.DCIs == 1){
DCIs.vals <- data.frame(ID=integer(length(nodefile$ID)), DCIs=double(length(nodefile$ID)) )
j <- 1
for (i in unique(nodefile$ID)){
DCId.data2 <- all.paths[all.paths$end==i, ]
DCId.data2$val1 <- DCId.data2$pass * (DCId.data2$Start.Length/tot.length)
DCIs <- sum(DCId.data2$val1)
DCIs.vals$ID[j] <- i
DCIs.vals$DCIs[j] <- DCIs
j <- j+1
}
}else{
DCIs.vals <- "DCIs was not calculated. To caluclate DCIs set calc.DCIs to 1"
}
list("Index" = DCI.results, "DCIs" = DCIs.vals)
}
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode) #The list of edges
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- 1
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed")
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 100 #default value
}else{
Nodes$Qual <- Parth[,Quality]
}
#Nodes$Qual <- 100 #default value, can be changed
Nodes$PermDS <- 1 #default value, completely permeable
Nodes$PermUS <- Parth$PermPass #assigning a permeability to move from segment downstream into the focal segment
Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
#Parth[,Quality]
list("graph" = graph, "Nodes" = Nodes)
}
WC <- read.csv(file = "testWC.csv", header=T) #Select file that describes network
WC.prep <- calc.prep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
WC.prep
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
WC.prep
WC <- read.csv(file = "testWC.csv", header=T) #Select file that describes network
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
WC.prep
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode) #The list of edges
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- 1
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed")
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 1 #default value
}else{
Nodes$Qual <- Parth[,Quality]/100
}
#Nodes$Qual <- 100 #default value, can be changed
Nodes$PermDS <- 1 #default value, completely permeable
Nodes$PermUS <- Parth$PermPass #assigning a permeability to move from segment downstream into the focal segment
Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
#Parth[,Quality]
list("graph" = graph, "Nodes" = Nodes)
}
DCI.calc <- function(nodefile, graphfile, mouth, calc.DCIs = 0){
#Construct a table with the start and end of each path between all segments, length of that path,
#the product of the permeabilites of barriers on that path, the length of the start segment, and the length of the last segment
all.paths <- NULL
for (b in 1:length(nodefile$ID)) {
k <- unique(nodefile$ID)[b]
paths <- all_simple_paths(graph=graphfile, from=k, mode = "all") #returns path from a segment to all other segements
start <- sapply(paths, "[[", 1) #Identify the starting segment
end <- sapply(paths, tail, 1) #Identify the final segment
p.length <- NULL
pass <- NULL
for (j in 1:(length(unique(nodefile$ID))-1)) {
p.length2 <- 0 #Stores the length of the path
pass2 <- 1
for (c in paths[[j]]) {
i <- unique(nodefile$ID)[c]
p.length2 <- p.length2 + (nodefile$Area[i] * nodefile$Qual[i]) #product of length of path and quality
pass2 <- pass2 * (nodefile$PermUS[i] * nodefile$PermDS[i])
}
p.length <- c(p.length, p.length2)
pass <- c(pass, pass2)
}
all.paths2 <- data.frame(start, end, p.length, pass)
itself <- c(k, k, nodefile$Area[k], nodefile$PermUS[k] * nodefile$PermUS[k])
all.paths <- rbind(all.paths, all.paths2, itself)
}
all.paths$Start.Length <- nodefile$Area[match(all.paths$start, nodefile$ID)]
all.paths$End.Length <- nodefile$Area[match(all.paths$end, nodefile$ID)]
#DCIp Calculation
tot.length <- sum(nodefile$Area)
DCIp <- 0
for (i in 1:nrow(all.paths)) {
DCIp <- DCIp + (all.paths$pass[i] * (all.paths$Start.Length[i]/tot.length) * (all.paths$End.Length[i]/tot.length))
}
DCId.data <- all.paths[all.paths$end==mouth, ]
DCId.data$val1 <- DCId.data$pass * (DCId.data$Start.Length/tot.length)
DCId <- sum(DCId.data$val1)
#Combine DCIp and DCId into output
DCI.results <- data.frame(DCIp, DCId)
colnames(DCI.results) <- c("DCIp", "DCId")
#Calculating DCIs, recalculate DCId for each segement as the mouth of the network
if(calc.DCIs == 1){
DCIs.vals <- data.frame(ID=integer(length(nodefile$ID)), DCIs=double(length(nodefile$ID)) )
j <- 1
for (i in unique(nodefile$ID)){
DCId.data2 <- all.paths[all.paths$end==i, ]
DCId.data2$val1 <- DCId.data2$pass * (DCId.data2$Start.Length/tot.length)
DCIs <- sum(DCId.data2$val1)
DCIs.vals$ID[j] <- i
DCIs.vals$DCIs[j] <- DCIs
j <- j+1
}
}else{
DCIs.vals <- "DCIs was not calculated. To caluclate DCIs set calc.DCIs to 1"
}
list("Index" = DCI.results, "DCIs" = DCIs.vals)
}
WC <- read.csv(file = "testWC.csv", header=T) #Select file that describes network
View(WC)
WC.prep <- calc.prep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
WC.prep <- calc.prep(Parth = WC, Quality="Qual) #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
WC.prep
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode) #The list of edges
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- 1
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed")
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 1 #default value
}else{
Nodes$Qual <- Parth[,Quality]/100
}
#Nodes$Qual <- 100 #default value, can be changed
Nodes$PermDS <- 1 #default value, completely permeable
Nodes$PermUS <- Parth$PermPass #assigning a permeability to move from segment downstream into the focal segment
Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
Nodes$Qual
#list("graph" = graph, "Nodes" = Nodes)
}
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
WC.prep
WC.prep <- calc.prep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WC.prep
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode) #The list of edges
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- 1
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed")
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 1 #default value
}else{
Nodes$Qual <- Parth[,Quality]/100
}
#Nodes$Qual <- 100 #default value, can be changed
Nodes$PermDS <- 1 #default value, completely permeable
Nodes$PermUS <- Parth$PermPass #assigning a permeability to move from segment downstream into the focal segment
Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
list("graph" = graph, "Nodes" = Nodes)
}
WC.prep$Nodes
WC.prep <- calcp.rep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WC.prep <- calcprep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WC.prep <- calc.prep(Parth = WC, Quality="Default") #prepare the files for DCI calculation
WC.prep
WC.prep$Nodes
nodefile <- WC.prep$Nodes
WC.prep$graph
graphfile <- WC.prep$graph
mouth <- 6
calc.DCIs <- 1
all.paths <- NULL
for (b in 1:length(nodefile$ID)) {
k <- unique(nodefile$ID)[b]
paths <- all_simple_paths(graph=graphfile, from=k, mode = "all") #returns path from a segment to all other segements
start <- sapply(paths, "[[", 1) #Identify the starting segment
end <- sapply(paths, tail, 1) #Identify the final segment
p.length <- NULL
pass <- NULL
for (j in 1:(length(unique(nodefile$ID))-1)) {
p.length2 <- 0 #Stores the length of the path
pass2 <- 1
for (c in paths[[j]]) {
i <- unique(nodefile$ID)[c]
p.length2 <- p.length2 + (nodefile$Area[i] * nodefile$Qual[i]) #product of length of path and quality
pass2 <- pass2 * (nodefile$PermUS[i] * nodefile$PermDS[i])
}
p.length <- c(p.length, p.length2)
pass <- c(pass, pass2)
}
all.paths2 <- data.frame(start, end, p.length, pass)
itself <- c(k, k, nodefile$Area[k], nodefile$PermUS[k] * nodefile$PermUS[k])
all.paths <- rbind(all.paths, all.paths2, itself)
}
all.paths
nodefile$Qual
all.paths$Start.Length <- nodefile$Area[match(all.paths$start, nodefile$ID)]
all.paths$End.Length <- nodefile$Area[match(all.paths$end, nodefile$ID)]
all.paths
tot.length <- sum(nodefile$Area)
tot.length
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
nodefile <- WC.prep$Nodes
graphfile <- WC.prep$graph
mouth <- 6
calc.DCIs <- 1
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
all.paths <- NULL
for (b in 1:length(nodefile$ID)) {
k <- unique(nodefile$ID)[b]
paths <- all_simple_paths(graph=graphfile, from=k, mode = "all") #returns path from a segment to all other segements
start <- sapply(paths, "[[", 1) #Identify the starting segment
end <- sapply(paths, tail, 1) #Identify the final segment
p.length <- NULL
pass <- NULL
for (j in 1:(length(unique(nodefile$ID))-1)) {
p.length2 <- 0 #Stores the length of the path
pass2 <- 1
for (c in paths[[j]]) {
i <- unique(nodefile$ID)[c]
p.length2 <- p.length2 + (nodefile$Area[i] * nodefile$Qual[i]) #product of length of path and quality
pass2 <- pass2 * (nodefile$PermUS[i] * nodefile$PermDS[i])
}
p.length <- c(p.length, p.length2)
pass <- c(pass, pass2)
}
all.paths2 <- data.frame(start, end, p.length, pass)
itself <- c(k, k, nodefile$Area[k], nodefile$PermUS[k] * nodefile$PermUS[k])
all.paths <- rbind(all.paths, all.paths2, itself)
}
all.paths$Start.Length <- nodefile$Area[match(all.paths$start, nodefile$ID)]
all.paths$End.Length <- nodefile$Area[match(all.paths$end, nodefile$ID)]
all.paths$Start.Length <- nodefile$Area[match(all.paths$start, nodefile$ID)]
all.paths
all.paths$Start.Length <- (nodefile$Area[match(all.paths$start, nodefile$ID)]) * (nodefile$Qual[match(all.paths$start, nodefile$ID)])
all.paths$End.Length <- (nodefile$Area[match(all.paths$end, nodefile$ID)]) * (nodefile$Qual[match(all.paths$end, nodefile$ID)])
all.paths
DCI.calc <- function(nodefile, graphfile, mouth, calc.DCIs = 0){
#Construct a table with the start and end of each path between all segments, length of that path,
#the product of the permeabilites of barriers on that path, the length of the start segment, and the length of the last segment
all.paths <- NULL
for (b in 1:length(nodefile$ID)) {
k <- unique(nodefile$ID)[b]
paths <- all_simple_paths(graph=graphfile, from=k, mode = "all") #returns path from a segment to all other segements
start <- sapply(paths, "[[", 1) #Identify the starting segment
end <- sapply(paths, tail, 1) #Identify the final segment
p.length <- NULL
pass <- NULL
for (j in 1:(length(unique(nodefile$ID))-1)) {
p.length2 <- 0 #Stores the length of the path
pass2 <- 1
for (c in paths[[j]]) {
i <- unique(nodefile$ID)[c]
p.length2 <- p.length2 + (nodefile$Area[i] * nodefile$Qual[i]) #product of length of path and quality
pass2 <- pass2 * (nodefile$PermUS[i] * nodefile$PermDS[i])
}
p.length <- c(p.length, p.length2)
pass <- c(pass, pass2)
}
all.paths2 <- data.frame(start, end, p.length, pass)
itself <- c(k, k, nodefile$Area[k], nodefile$PermUS[k] * nodefile$PermUS[k])
all.paths <- rbind(all.paths, all.paths2, itself)
}
all.paths$Start.Length <- (nodefile$Area[match(all.paths$start, nodefile$ID)]) * (nodefile$Qual[match(all.paths$start, nodefile$ID)])
all.paths$End.Length <- (nodefile$Area[match(all.paths$end, nodefile$ID)]) * (nodefile$Qual[match(all.paths$end, nodefile$ID)])
#DCIp Calculation
tot.length <- sum(nodefile$Area)
DCIp <- 0
for (i in 1:nrow(all.paths)) {
DCIp <- DCIp + (all.paths$pass[i] * (all.paths$Start.Length[i]/tot.length) * (all.paths$End.Length[i]/tot.length))
}
DCId.data <- all.paths[all.paths$end==mouth, ]
DCId.data$val1 <- DCId.data$pass * (DCId.data$Start.Length/tot.length)
DCId <- sum(DCId.data$val1)
#Combine DCIp and DCId into output
DCI.results <- data.frame(DCIp, DCId)
colnames(DCI.results) <- c("DCIp", "DCId")
#Calculating DCIs, recalculate DCId for each segement as the mouth of the network
if(calc.DCIs == 1){
DCIs.vals <- data.frame(ID=integer(length(nodefile$ID)), DCIs=double(length(nodefile$ID)) )
j <- 1
for (i in unique(nodefile$ID)){
DCId.data2 <- all.paths[all.paths$end==i, ]
DCId.data2$val1 <- DCId.data2$pass * (DCId.data2$Start.Length/tot.length)
DCIs <- sum(DCId.data2$val1)
DCIs.vals$ID[j] <- i
DCIs.vals$DCIs[j] <- DCIs
j <- j+1
}
}else{
DCIs.vals <- "DCIs was not calculated. To caluclate DCIs set calc.DCIs to 1"
}
list("Index" = DCI.results, "DCIs" = DCIs.vals)
}
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
