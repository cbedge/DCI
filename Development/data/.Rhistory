DistToMouth <- function(nodefile, graphfile, mouth){
#Construct a table with the start and end of each path between all segments, length of that path,
#the product of the permeabilites of barriers on that path, the length of the start segment, and the length of the last segment
all.paths <- NULL
for (b in 1:length(nodefile$ID)) {
k <- unique(nodefile$ID)[b]
paths <- all_simple_paths(graph=graphfile, from=k, mode = "all") #returns path from a segment to all other segements
start <- sapply(paths, "[[", 1) #Identify the starting segment
end <- sapply(paths, tail, 1) #Identify the final segment
p.length <- NULL
for (j in 1:(length(unique(nodefile$ID))-1)) {
p.length2 <- 0 #Stores the length of the path
for (c in paths[[j]]) {
i <- unique(nodefile$ID)[c]
p.length2 <- p.length2 + (nodefile$Area[i]) #product of length of path and quality
}
p.length <- c(p.length, p.length2)
}
all.paths2 <- data.frame(start, end, p.length)
itself <- c(k, k, nodefile$Area[k])
all.paths <- rbind(all.paths, all.paths2, itself)
}
all.paths$BarID <- nodefile$Junction[match(all.paths$start, nodefile$ID)]
ToMouth <- all.paths[all.paths$end==mouth, ]
ToMouth
}
calc.prep <- function(Parth, Quality = "Default"){
Edge <- cbind(Parth$Fnode, Parth$Tnode, Parth$PermUS, Parth$PermDS) #The list of edges, change to now include US perm
#Turning the list of edges into an adjacency matrix
#For this to run correctly segments must be labelled 1, 2, 3... with no missing segments.
Edge.adj <- matrix(0, nrow=length(Edge[,1]), ncol=length(Edge[,1]))
for (i in 1:length(Edge[,1]))
{
Edge.adj[Edge[i,1], Edge[i,2]] <- Edge[i,3] #now a weighted matrix by US perm
Edge.adj[Edge[i,2], Edge[i,1]] <- Edge[i,4] #weight by DS perm
}
#Now we create a directed graph of the river network from the adjacency matrix
graph <- graph.adjacency(t(Edge.adj), mode="directed", weighted=TRUE) #Create a weighted graph
#Now we create a Node file that contains all the attributes to run DCI
Nodes <- data.frame(matrix(NA, nrow=length(Parth[,1]), ncol=6))
colnames(Nodes) <- c("Junction", "ID", "Area", "Qual", "PermUS", "PermDS")
Nodes$ID <- Parth$Fnode #upstream segment
Nodes$Junction <- Parth$BARRIER_CO #barrier downstream of the segment, if present
Nodes$Area <- Parth$Shape_Leng #length of segment
if(Quality == "Default"){
Nodes$Qual <- 1 #default value
}else{
Nodes$Qual <- Parth[,Quality]/100
}
Nodes$PermDS <- Parth$PermDS #permeability to move from focal segment to downstream segment
Nodes$PermUS <- Parth$PermUS #assigning a permeability to move from segment downstream into the focal segment
#Nodes$PermUS[is.na(Nodes$PermUS)] <- 1 #Replace NA's with 1 for completely permeable
list("graph" = graph, "Nodes" = Nodes, "edgematrix" = Edge.adj)
}
library(igraph)
DCI.calc <- function(nodefile, graphfile, mouth, edgemat, calc.DCIs = 0){
#Construct a table with the start and end of each path between all segments, length of that path,
#the product of the permeabilites of barriers on that path, the length of the start segment, and the length of the last segment
path.vals <- NULL
for (k in 1:length(nodefile[,1])) {
path <- all_simple_paths(graph = graphfile, from = k, to = V(graphfile), mode = "all")
start.seg <- sapply(path, "[[", 1) #Identify the starting segment
end.seg <- sapply(path, tail, 1) #Identify the final segment
path.vals2 <- as.data.frame(cbind(start.seg, end.seg)) #combine start and end segments together
for (j in 1:length(path)) {
cij <- 1 #Default value for cij
for (i in 1:(length(path[[j]])-1)) {
cij <- cij * (edgemat[path[[j]][i], path[[j]][i+1]] * edgemat[path[[j]][i+1], path[[j]][i]])
}
path.vals2$cij[j] <- cij
}
itself <- c(k,k,  1)
path.vals <- rbind(path.vals, path.vals2, itself)
}
path.vals$Start.Length <- (nodefile$Area[match(path.vals$start, nodefile$ID)]) * (nodefile$Qual[match(path.vals$start, nodefile$ID)])
path.vals$End.Length <- (nodefile$Area[match(path.vals$end, nodefile$ID)]) * (nodefile$Qual[match(path.vals$end, nodefile$ID)])
#DCIp Calculation
tot.length <- sum(nodefile$Area)
DCIp <- 0
for (i in 1:nrow(path.vals)) {
DCIp <- DCIp + (path.vals$cij[i] * (path.vals$Start.Length[i]/tot.length) * (path.vals$End.Length[i]/tot.length))
}
#DCId Calculation
DCId.data <- path.vals[path.vals$end.seg==mouth, ]
DCId.data$val1 <- DCId.data$cij * (DCId.data$Start.Length/tot.length)
DCId <- sum(DCId.data$val1)
#Combine DCIp and DCId into output
DCI.results <- data.frame(DCIp, DCId)
colnames(DCI.results) <- c("DCIp", "DCId")
#Calculating DCIs, recalculate DCId for each segement as the mouth of the network
if(calc.DCIs == 1){
DCIs.vals <- data.frame(ID=integer(length(nodefile$ID)), DCIs=double(length(nodefile$ID)) )
j <- 1
for (i in unique(nodefile$ID)){
DCId.data2 <- path.vals[path.vals$end.seg==i, ]
DCId.data2$val1 <- DCId.data2$cij * (DCId.data2$Start.Length/tot.length)
DCIs <- sum(DCId.data2$val1)
DCIs.vals$ID[j] <- i
DCIs.vals$DCIs[j] <- DCIs
j <- j+1
}
}else{
DCIs.vals <- "DCIs was not calculated. To caluclate DCIs set calc.DCIs to 1"
}
list("Index" = DCI.results, "DCIs" = DCIs.vals)
}
setwd("C:/Users/christopher.edge/Documents/GitHub/DCI/Development/Data") #Update directory to local
WC <- read.csv(file = "testWC_v2.csv", header=T) #Select file that describes network
WC.prep <- calc.prep(Parth = WC, Quality="Qual") #prepare the files for DCI calculation
plot(WC.prep$graph, layout=layout_with_fr, vertex.size=4, vertex.label.dist=0.5, vertex.color="red", edge.arrow.size=0.5, edge.label=(round(E(WC.prep$graph)$weight, 3)), edge.curved=rep(0.5, ecount(WC.prep$graph))) #plot the graph
WCDCI <- DCI.calc(nodefile = WC.prep$Nodes, graphfile = WC.prep$graph, edgemat = WC.prep$edgematrix, mouth=6, calc.DCIs = 1) #calculate DCI
WCDCI$Index #returns DCId and DCIp values
WCDCI$DCIs #returns DCIs values if calculated
